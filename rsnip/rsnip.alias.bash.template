# rsnip.bash completion and aliases
{%- macro section(name) -%}
# =================================== {{ name }} ===================================
{%- endmacro -%}

# Unset any existing aliases and completions
complete -r rsnip > /dev/null 2>&1  # Remove any existing completion
{%- for type, config in snippet_types %}
{%- if config.alias %}
unalias {{ config.alias }} 2>/dev/null  # Remove existing alias
complete -r "{{ config.alias }}" > /dev/null 2>&1  # Remove existing completion
{%- endif %}
{%- endfor %}

# Set up aliases
{%- for type, config in snippet_types %}
{%- if config.alias %}
alias {{ config.alias }}="rsnip copy --ctype {{ type }} --input"
{%- endif %}
{%- endfor %}

# Enhanced completion function
_rsnip_complete() {
    local cur prev cmd
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    # Detect if we're using an alias or full command
    local is_alias=false
    local alias_type=""
    case "${COMP_WORDS[0]}" in
    {%- for type, config in snippet_types %}
    {%- if config.alias %}
        "{{ config.alias }}")
            is_alias=true
            alias_type="{{ type }}"
            ;;
    {%- endif %}
    {%- endfor %}
        *)
            # List of available commands
            local commands="copy edit list types"

            # If completing a command
            if [[ ${COMP_CWORD} -eq 1 ]]; then
                COMPREPLY=( $(compgen -W "${commands}" -- ${cur}) )
                return 0
            fi
            ;;
    esac

    # Get available snippet types
    local snippet_types=$(rsnip types --list)

    case "${prev}" in
        "--ctype"|"-c")
            COMPREPLY=( $(compgen -W "${snippet_types}" -- ${cur}) )
            return 0
            ;;
        "complete"|"copy")
            COMPREPLY=( $(compgen -W "--ctype --input --interactive" -- ${cur}) )
            return 0
            ;;
    esac

    # Handle alias cases
    if [[ ${is_alias} == true ]]; then
        # Save current terminal state
        tput smcup

        local result
        result="$(rsnip complete --interactive --ctype "${alias_type}" --input "${cur}")"

        # Restore terminal state
        tput rmcup

        if [[ -n "$result" ]]; then
            COMPREPLY=("$result")
            # Redraw line after fzf closes
            printf '\e[5n'
        fi
        return 0
    fi

    # If we're completing an input and have a type specified
    local ctype=""
    for ((i=1; i<COMP_CWORD; i++)); do
        if [[ "${COMP_WORDS[i]}" == "--ctype" || "${COMP_WORDS[i]}" == "-c" ]]; then
            ctype="${COMP_WORDS[i+1]}"
            break
        fi
    done

    if [[ -n "${ctype}" && "${prev}" == "--input" ]]; then
        # Save current terminal state
        tput smcup

        local result
        result="$(rsnip complete --interactive --ctype "${ctype}" --input "${cur}")"

        # Restore terminal state
        tput rmcup

        if [[ -n "$result" ]]; then
            COMPREPLY=("$result")
            # Redraw line after fzf closes
            printf '\e[5n'
        fi
    fi
}

# Enable line editing features needed for interactive completion
if [[ :"${SHELLOPTS}": =~ :(vi|emacs): && ${TERM} != 'dumb' ]]; then
    # Bind escape sequence for redrawing line after fuzzy selection
    bind '"\e[0n": redraw-current-line' &>/dev/null
fi

# Setup completion for command and all aliases
complete -F _rsnip_complete rsnip
{%- for type, config in snippet_types %}
{%- if config.alias %}
complete -F _rsnip_complete "{{ config.alias }}"
{%- endif %}
{%- endfor %}

{{ section("Usage") }}
# To initialize rsnip, add this to your shell configuration file (usually ~/.bashrc):
#
# source <(rsnip --generate bash)
